#include <vector>
#include <list>
#include <set>
#include <map>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <string>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <unordered_map>
using namespace std;

#define px first
#define py second
#define pb push_back
#define mp make_pair
#define pque priority_queue
#define lowbit(x) ((x) & -(x))
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(), (v).end()
#define clr(v, e) memset(v, e, sizeof(v))
#define rep(it, v) for (auto it : v)
#define forn(i, n) for (int i = 0; i < (n); ++ i)
#define rforn(i, n) for (int i = (n) - 1; i >= 0; -- i)
#define form(i, a, b) for (int i = (a); i <= (b); ++ i)
#define rform(i, a, b) for (int i = (b); i >= (a); -- i)
#define forv(i, v) for (int i = 0; i < sz(v); ++ i)
#define iter(it, v) for (auto it = v.begin(); it != v.end(); ++ it)

typedef long long lint;
typedef vector<int> vint;
typedef vector<string> vstring;
typedef pair<int, int> pint;
typedef vector<lint> vlint;
typedef vector<pint> vpint;

class GridSortMax {
public:
	string findMax(int, int, vector <int>);
};

const int maxn = 55;

int n, m;
int g[maxn][maxn];
bool row[maxn], col[maxn];

bool find_grid(int & x, int & y, const int w) {
    forn (i, n) forn (j, m) if (g[i][j] == w) {
        x = i, y = j;
        return 1;
    }
    return 0;
}

bool find_row(int & x, const int y, const int w) {
    forn (i, n) if (g[i][y] == w) {
        x = i;
        return 1;
    }
    return 0;
} 

bool find_col(const int x, int & y, const int w) {
    forn (j, m) if (g[x][j] == w) {
        y = j;
        return 1;
    }
    return 0;
}

void swap_row(const int a, const int b) {
    if (a == b) return;
    forn (i, m) swap(g[a][i], g[b][i]);
}

void swap_col(const int a, const int b) {
    if (a == b) return;
    forn (i, n) swap(g[i][a], g[i][b]);
}

string GridSortMax::findMax(int nn, int mm, vector<int> grid) {
    int idx = 0;
    n = nn, m = mm;
    clr(row, 0), clr(col, 0);
	forn (i, n) forn (j, m) g[i][j] = grid[idx ++];
    idx = 1;
    forn (i, n) forn (j, m) {
        if (g[i][j] == idx) {
            row[i] = col[j] = 1;
        } else {
            int x = i, y = j;
            if (row[i] == 0 || col[j] == 0) {
                if (row[i] == 1) {
                    if (find_col(x, y, idx) && col[y] == 0) {
                        swap_col(j, y);
                        col[j] = 1;
                    }
                } else if (col[j] == 1) {
                    if (find_row(x, y, idx) && row[x] == 0) {
                        swap_row(i, x);
                        row[i] = 1;
                    }
                } else {
                    if (find_grid(x, y, idx) && row[x] == 0 && col[y] == 0) {
                        swap_row(i, x);
                        swap_col(j, y);
                        row[i] = col[j] = 1;
                    }
                }
            }
        }
        ++ idx;
    }
    string ans = "";
    idx = 1;
    forn (i, n) forn (j, m) {
        if (g[i][j] == idx ++) {
            ans += "1";
        } else {
            ans += "0";
        }
    }
    return ans;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, int p0, int p1, vector <int> p2, bool hasAnswer, string p3) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p2[i];
	}
	cout << "}";
	cout << "]" << endl;
	GridSortMax *obj;
	string answer;
	obj = new GridSortMax();
	clock_t startTime = clock();
	answer = obj->findMax(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p3 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	int p1;
	vector <int> p2;
	string p3;
	
	{
	// ----- test 0 -----
	p0 = 2;
	p1 = 2;
	int t2[] = {1,2,3,4};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = "1111";
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 2;
	p1 = 2;
	int t2[] = {2,1,3,4};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = "1100";
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 2;
	p1 = 2;
	int t2[] = {4,2,3,1};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = "1001";
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 1;
	p1 = 10;
	int t2[] = {10,6,2,3,5,7,1,9,4,8};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = "1111111111";
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 3;
	p1 = 5;
	int t2[] = {5,2,10,7,9,3,4,14,11,1,15,12,6,8,13};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = "101100100100000";
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	p0 = 6;
	p1 = 2;
	int t2[] = {3,9,5,1,10,6,2,7,8,11,12,4};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	p3 = "100000101010";
	all_right = KawigiEdit_RunTest(5, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// Charlie has a grid of n rows by m columns.
// The rows are numbered 0 through n-1 from top to bottom.
// The columns are numbered 0 through m-1 from left to right.
// 
// 
// 
// Each cell of the grid contains a positive integer.
// The integers in Charlie's grid are a permutation of the numbers 1 through n*m.
// (I.e., each of these numbers occurs in the grid exactly once.)
// 
// 
// 
// Given a grid, its value list is a sequence constructed by listing all values in the grid in row major order.
// That is, we first list the values in row 0 from left to right, then the values in row 1 from left to right, and so on.
// 
// 
// 
// You are given the ints n and m: the dimensions of Charlie's grid.
// You are also given a vector <int> grid: the value list for Charlie's grid.
// (Formally, grid[i*m+j] is the value stored in row i, column j of the grid.)
// 
// 
// 
// In Charlie's eyes, the most beautiful of all grids is the sorted grid: the grid whose value list is the ordered ordered sequence {1,2,3,...,n*m}.
// 
// 
// 
// Given a grid, its similarity string is a string of zeroes and ones that describes the similarity between that particular grid and the sorted grid. More precisely:
// 
// The similarity string is a string of length n*m.
// For each i, character i of the similarity string is '1' if both grids have the same i-th element in their value lists, and it is '0' if those values differ. (All indices in the previous sentence are 0-based.)
// 
// 
// 
// 
// For example, suppose n=2 and m=3. The sorted grid has the value list {1,2,3,4,5,6}, and its similarity string is "111111". Another possible grid with these dimensions has the value list {1,5,2,4,3,6}. The similarity string for this grid is "100101".
// 
// 
// 
// Charlie can modify his grid in two ways: He may swap any two rows, and he may swap any two columns.
// He wants to use these operations to obtain a grid with the lexicographically largest possible similarity string.
// Find and return that string.
// 
// 
// DEFINITION
// Class:GridSortMax
// Method:findMax
// Parameters:int, int, vector <int>
// Returns:string
// Method signature:string findMax(int n, int m, vector <int> grid)
// 
// 
// CONSTRAINTS
// -n,m will be between 1 and 50, inclusive.
// -grid will be a permutation of [1,...,n*m]
// 
// 
// EXAMPLES
// 
// 0)
// 2
// 2
// {
//  1,2,
//  3,4
// }
// 
// Returns: "1111"
// 
// Charlie's grid is the sorted grid.
// Its similarity string is therefore "1111".
// Charlie should make no changes to the grid, as this is already the lexicographically largest of all possible strings.
// 
// 1)
// 2
// 2
// {
//  2,1,
//  3,4
// }
// 
// Returns: "1100"
// 
// The similarity string for Charlie's current grid is "0011", as the values 3 and 4 are in the same places as in the sorted grid.
// Charlie should swap the two columns.
// That swap will produce a grid with the similarity string "1100": now the values 1 and 2 are in their correct places but the values 3 and 4 aren't.
// 
// 2)
// 2
// 2
// {
//  4,2,
//  3,1
// }
// 
// Returns: "1001"
// 
// 
// 
// 3)
// 1
// 10
// {10,6,2,3,5,7,1,9,4,8}
// 
// Returns: "1111111111"
// 
// 
// 
// 4)
// 3
// 5
// {
//  5,2,10,7,9,
//  3,4,14,11,1,
//  15,12,6,8,13
// }
// 
// Returns: "101100100100000"
// 
// 
// 
// 5)
// 6
// 2
// {
//  3,9,
//  5,1,
//  10,6,
//  2,7,
//  8,11,
//  12,4
// }
// 
// Returns: "100000101010"
// 
// 
// 
// END KAWIGIEDIT TESTING








//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
