#include <vector>
#include <list>
#include <set>
#include <map>
#include <deque>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <string>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <unordered_map>
using namespace std;

#define px first
#define py second
#define pb push_back
#define mp make_pair
#define pque priority_queue
#define lowbit(x) ((x) & -(x))
#define sz(v) ((int)(v).size())
#define all(v) (v).begin(), (v).end()
#define clr(v, e) memset(v, e, sizeof(v))
#define rep(it, v) for (auto it : v)
#define forn(i, n) for (int i = 0; i < (n); ++ i)
#define rforn(i, n) for (int i = (n) - 1; i >= 0; -- i)
#define form(i, a, b) for (int i = (a); i <= (b); ++ i)
#define rform(i, a, b) for (int i = (b); i >= (a); -- i)
#define forv(i, v) for (int i = 0; i < sz(v); ++ i)
#define iter(it, v) for (auto it = v.begin(); it != v.end(); ++ it)

typedef long long lint;
typedef vector<int> vint;
typedef vector<string> vstr;
typedef pair<int, int> pint;
typedef vector<lint> vlint;
typedef vector<pint> vpint;

class RepeatedStrings {
public:
	string findKth(string, int);
};

bool check(const string & s, const string & t) {
    int k = 0;
    rep (c, s) {
        if (t[k] == c) {
            if (++ k == sz(t)) return 1;
        }
    }
    return 0;
}

string RepeatedStrings::findKth(string s, int k) {
	vstr vs;
    vs.pb("()");
    const int n = sz(s);
    for (int k = 4; k <= n; k += 2) {
        forv (i, vs) {
            if ((k - 2) % sz(vs[i]) == 0) {
                string t = vs[i];
                int m = (k - 2) / sz(vs[i]) - 1;
                forn (j, m) t += vs[i];
                vs.pb("(" + t + ")");
            }
        }
    }
    if (sz(vs) < k) return "";
    sort(all(vs));
    rep (it, vs) {
        if (check(s, it)) {
            if (-- k == 0) return it;
        }
    }
    return "";
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, string p0, int p1, bool hasAnswer, string p2) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"" << "," << p1;
	cout << "]" << endl;
	RepeatedStrings *obj;
	string answer;
	obj = new RepeatedStrings();
	clock_t startTime = clock();
	answer = obj->findKth(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p2 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	string p0;
	int p1;
	string p2;
	
	{
	// ----- test 0 -----
	p0 = "()))((()())";
	p1 = 3;
	p2 = "(())";
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = "))))))))))))((((((((((";
	p1 = 1;
	p2 = "";
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = "(())(()(()))";
	p1 = 1;
	p2 = "(((())))";
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = "(())))()((())())";
	p1 = 8;
	p2 = "()";
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = "(()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())";
	p1 = 64;
	p2 = "(((((((((((((()()()())(()()()())))))))))))))";
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	p0 = "(";
	p1 = 1000000000;
	p2 = "";
	all_right = KawigiEdit_RunTest(5, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// PROBLEM STATEMENT
// 
// The set of good strings is defined as follows:
// 
// The string "()" is a good string.
// If S is a good string, each string of the form "(SS...S)" is a good string. That is, if you take any good string, concatenate an arbitrary number of its copies, and then surround the result in parentheses, you will produce another good string.
// Nothing else is a good string.
// 
// 
// 
// 
// A subsequence of a string X is any string that can be obtained from X by erasing zero or more of its characters.
// 
// 
// 
// You are given a string s.
// Each character of s is either '(' or ')'.
// 
// 
// 
// Let G be the set of all distinct subsequences of s that are good strings.
// Note that G contains each good subsequence only once, even if it can be produced in multiple ways.
// For example, for s="(()())" the set G contains the strings "()", "(())", and "(()())".
// 
// 
// 
// You are also given an int k.
// If there are fewer than k strings in G, return the empty string.
// Otherwise, return the k-th lexicographically smallest string in G, counting from 1.
// 
// 
// DEFINITION
// Class:RepeatedStrings
// Method:findKth
// Parameters:string, int
// Returns:string
// Method signature:string findKth(string s, int k)
// 
// 
// CONSTRAINTS
// -s will have between 1 and 150 characters, inclusive.
// -Each character in s must be '(' or ')'.
// -k will be between 1 and 10^9, inclusive.
// 
// 
// EXAMPLES
// 
// 0)
// "()))((()())"
// 3
// 
// Returns: "(())"
// 
// This string has the following distinct good subsequences in sorted order: "((()))", "(()())", "(())", "()". The third one in this list is "(())".
// 
// 1)
// "))))))))))))(((((((((("
// 1
// 
// Returns: ""
// 
// This string has no good subsequences.
// 
// 2)
// "(())(()(()))"
// 1
// 
// Returns: "(((())))"
// 
// 
// 
// 3)
// "(())))()((())())"
// 8
// 
// Returns: "()"
// 
// 
// 
// 4)
// "(()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()())"
// 64
// 
// Returns: "(((((((((((((()()()())(()()()())))))))))))))"
// 
// 
// 
// 5)
// "("
// 1000000000
// 
// Returns: ""
// 
// 
// 
// END KAWIGIEDIT TESTING









//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
